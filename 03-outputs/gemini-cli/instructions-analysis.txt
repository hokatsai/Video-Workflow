Loaded cached credentials.
好的，這是有關 `gemini-instructions.txt` 的內容總結與使用建議：

### Gemini CLI 使用說明總結

這份文件說明如何使用 `gemini` 命令列工具，透過其龐大的上下文視窗（Context Window）來分析大型程式庫。核心功能是利用 `@` 語法將大量的檔案或整個目錄內容直接納入問題提示（Prompt）中。

---

#### 一、關鍵指令語法

`gemini` 工具的核心是 `@` 符號，用於指定要分析的檔案或目錄路徑。路徑是相對於您**執行 `gemini` 指令所在的目錄**。

*   **分析單一檔案：**
    ```bash
    gemini "@src/main.py 請解釋這個檔案的用途與結構"
    ```

*   **分析多個檔案：**
    ```bash
    gemini "@package.json @src/index.js 分析程式碼中使用的依賴項"
    ```

*   **分析整個目錄：**
    ```bash
    gemini "@src/ 請總結這個程式庫的架構"
    ```

*   **分析整個專案（目前目錄及其所有子目錄）：**
    ```bash
    gemini "@./ 請給我這個專案的整體概覽"
    ```
    或使用 `--all_files` 標誌：
    ```bash
    gemini --all_files "分析專案結構與依賴關係"
    ```

#### 二、適用情境

當您需要處理的程式碼規模超出一般上下文視窗限制時，就適合使用 `gemini` CLI。例如：

1.  **全域分析**：需要理解整個程式庫、大型目錄或多個大型檔案的內容。
2.  **架構與模式識別**：想了解專案的整體架構、設計模式或跨檔案的程式碼實作方式。
3.  **功能實作驗證**：檢查特定功能是否存在且如何實作，例如：
    *   `gemini "@src/ @lib/ 這個專案是否實作了暗黑模式？"`
    *   `gemini "@src/ @api/ 是否有實作 SQL 注入防護？"`
4.  **安全與效能檢查**：驗證特定的安全措施（如 JWT 驗證）、效能策略（如快取、速率限制）是否到位。
5.  **測試覆蓋率分析**：比較原始碼與測試檔案，以評估特定功能的測試完整性。

#### 三、注意事項

*   **相對路徑**：`@` 後面的路徑是相對於您**當前的工作目錄**，不是相對於專案根目錄。
*   **內容包含**：CLI 會將指定路徑下所有檔案的**完整內容**直接放入上下文中。
*   **唯讀分析**：進行程式碼分析是唯讀操作，不需擔心會修改檔案。
*   **精準提問**：您的問題越具體，Gemini 回傳的結果就越準確。例如，與其問「有 bug 嗎？」，不如問「檢查所有 API 端點是否都實作了 try-catch 錯誤處理？」

---

#### 四、如何在本地程式庫分析時善用它？

`gemini` CLI 是一個強大的程式碼探索與審計工具。建議採用**由廣到精**的分析策略：

1.  **第一步：建立宏觀理解 (Broad Overview)**
    從分析整個專案或核心目錄開始，以掌握整體架構和主要技術棧。
    ```bash
    # 了解 src 目錄的整體架構
    gemini "@src/ 請總結這個程式庫的架構、主要模組和它們的職責"
    ```

2.  **第二步：聚焦特定功能或問題 (Specific Investigation)**
    當您想了解某個特定功能、修復一個錯誤或進行重構時，可以將相關的目錄或檔案一起分析。
    ```bash
    # 假設要重構使用者認證流程
    gemini "@src/auth/ @src/middleware/ 說明使用者認證的完整流程，並列出所有相關的檔案與函式"
    ```

3.  **第三步：進行跨領域驗證 (Cross-cutting Concerns)**
    利用它來審查橫跨多個模組的議題，例如安全性、效能或程式碼品質。
    ```bash
    # 檢查整個後端是否有實作 API 速率限制
    gemini "@backend/ @middleware/ API 是否有實作速率限制？在哪裡實作的？"

    # 比較功能模組與其對應的測試
    gemini "@src/payment/ @tests/payment/ 支付模組的測試是否完整覆蓋了所有公開的函式？"
    ```

透過這種方式，您可以快速地在不熟悉的龐大程式庫中找到方向、驗證實作細節，並有效提升程式碼審查和開發的效率。
